---
title: "Lab 8 - Networks"
author: "YourNameGoesHere"
date: "For class Tuesday, April 5"
output:
  pdf_document:
    fig_height: 3
    fig_width: 5
---

```{r setup, include = FALSE}
# load packages
library(tidyverse)
library(kableExtra)

library(ggnetwork)
library(igraph)

# set code chunk defaults
knitr::opts_chunk$set(tidy = F, # display code as typed
                      size = "small", # slightly smaller code font
                      message = FALSE,
                      warning = FALSE,
                      comment = "\t") 

# set black & white default plot theme
theme_set(theme_classic()) 

# improve digit and NA display 
options(scipen = 1, knitr.kable.NA = '')
```

# Lab Purpose  

This lab is designed to help you develop skills involving the analysis of network data (graphs). We'll explore a dataset on migration between countries from 1960 to 2000 and also a dataset based on character interactions in George R.R. Martin's `A Storm of Swords`. 

The lab focuses on two main packages:

* igraph - this package has a lot of functionality for analysis of networks, including clustering algorithms - however, it doesn't produce the best visuals
* ggnetwork - this package helps with visualizations of networks (convert igraph objects so they can be plotted with ggplot2) and provides other useful functionality (network geometrics such as `geom_edges` and `geom_nodes`)

As usual, make sure you load each package in the `setup` code chunk above, after installing once (if necessary). You should have `igraph` installed from the prep already. 

# 1 - Country Migration Network

## Data and Setup

The following dataset contains migration counts for decades between 1960 and 2000 between the origin (`origincode`) and destination (`destcode`) countries given in the data. The lab is set up to look at the migration flows of females in 2000, but you can change this to males and/or any year you wish in the appropriate wrangling chunk below. 

<!-- 
Remember that you may need to adjust the path depending on where the data "lives" in relation to your .Rmd and where your working directory is. The command below assumes you have the data in a subfolder relative to the .Rmd file. 
-->

```{r}
# Read in dataset from data subfolder
migration_flows <- read_csv("data/migration-flows.csv")

# What are the variables?
glimpse(migration_flows)

# View a few rows to get a sense of the data
head(migration_flows, n = 10)
tail(migration_flows, n = 10)
```

First, we need to do some very minor wrangling to get our data ready for analyzing as a network: (1) include only rows with *positive* counts of female migration in 2000 and (2) keep only the variables `destcode`, `origincode`, and `Y2000`. How many rows are in this dataset?

<!-- Feel free to change to males and/or select a different year you are interested in -->

```{r}
migration_flows_choice <- migration_flows %>%
 filter(sex == "Female", Y2000 > 0) %>%
 select(origincode, destcode, Y2000)
```

This dataframe can be used to create a directional network object (called an "igraph") with edges indicating migration from the origin county to a destination country for the migration network of females in 2000. 

We'll be using `graph_from_data_frame()` from the **igraph** package. The order of the columns matters for directed graphs (first is the origin; second is the destination; third, if any, is an edge attribute).

```{r}
migration_igraph <- graph_from_data_frame(migration_flows_choice,
           directed = TRUE)
summary(migration_igraph)
```

Then we can get basic statistics about the network. 

```{r}
# Get descriptions and counts of vertices
V(migration_igraph) # not necessarily useful to print
vcount(migration_igraph)

# Get descriptions and counts of edges
E(migration_igraph) # not necessarily useful to print
ecount(migration_igraph)

# Get edge attribute, change to your year if different
edge_attr(migration_igraph, name = "Y2000") %>% 
 head()
```

> part a - How many nodes are in this network? How many edges? 
 
Solution: 



```{r, eval = FALSE}
# Alternative network construction

# Could also graph from edge list but need to 
## 1. create edge list matrix
migration_el <- migration_flows_choice %>%
 select(origincode, destcode) %>% 
 as.matrix()

## 2. create edge graph structure
migration_el_igraph <- graph_from_edgelist(el = migration_el, directed = TRUE)

## 3. add Y2000 as an edge attribute
migration_el_igraph <- set_edge_attr(graph = migration_el_igraph, 
                   name = "Y2000", 
                   value = migration_flows_choice$Y2000)

summary(migration_el_igraph)
```

We can plot the network with igraph, but the result isn't very visually appealing.

```{r, eval = FALSE}
# The graph plotting actually needs a seed in igraph to be reproducible
set.seed(231)
plot(migration_igraph)
```

While this can work for small graphs, we can create a better visualization of this network using `ggnetwork()` to convert the igraph object to a network object, and `ggplot()` to plot the network graph.

```{r, fig.align = "center", fig.height = 3.5}
migration_network <- ggnetwork(migration_igraph)
head(migration_network)

ggplot(data = migration_network, aes(x = x, y = y, 
          xend = xend, yend = yend)) +
 geom_edges(arrow = arrow(type = "closed", length = unit(8, "pt")),
    color = "lightgray") +
 geom_nodes() +
 geom_nodelabel(aes(label = name)) +
 theme_blank()
```

There are still too many countries for this to be really useful (unless you want to make it interactive and zoom in). So let's examine a subset of countries. You can pick the countries you want to explore. Be sure you pick a subset of 10 countries. 

The countries are all denoted by their 3 letter UN code, which you can explore here:

https://unstats.un.org/unsd/methodology/m49/

> part b - Run the code below to create a new migration flows dataset with the 10 countries you have chosen.

Solution:

```{r}
# Change these countries to ones of interest to you!

# Really, change the countries
mysubset <- c("BRA", "USA", "NAM", "LVA", "ITA", "JAM", "HUN",
              "GRL", "FJI", "NIC")

migration_sub <- migration_flows_choice %>%
 filter(destcode %in% mysubset, 
   origincode %in% mysubset)
```

> part c - Follow the steps in the code above to create a similar visualization but just for the 10 countries you selected, using only the minimal code you need to accomplish the task (e.g., you don't need to count edges). 

Solution:

```{r, fig.align = "center", fig.height = 3.5}

# you need to construct the network before you can plot it
# call the igraph version migration_sub_igraph
# call the ggnetwork version migration_sub_network


```

<!--
Now that you have your own subset of the network to look at - this is called an induced sub-graph by the way - be sure you commit and push your work!
-->


\newpage

# 2 - Customizing the network graph

The plot of this network is much clearer than a plot of the entire network. Let's see how we can customize the network graph further.

> part a - Recalling that `Y2000` represents female migration in 2000, is this an edge or vertex attribute? (Adjust question in your mind if you choose differently!)

Solution:



Let's modify the graph so that edge width is a function of migration flow size. In `ggplot()` we can do this using the `size` option in `geom_edges()`. 

```{r, fig.align = "center", fig.height = 3.5}
# assumes you called the network migration_sub_network
# change year in code and subtitle to whatever you chose
ggplot(data = migration_sub_network, 
    aes(x = x, y = y, 
      xend = xend, yend = yend)) +
 geom_edges(arrow = arrow(type = "closed", angle = 10),
       color = "gray50",
       aes(size = Y2000)) +
 geom_nodelabel(aes(label = name)) +
 labs(title = "Migration among selected countries",
    subtitle = "Among females in 2000",
    size = "Number who migrated") +
 theme_blank()
```

> part b - We could, instead, map edge color to the migration flow size. Which do you think is the more effective visual cue in this case?

Solution: 

```{r, fig.align = "center", fig.height = 3.5}
# Adjust based on your choices again
ggplot(data = migration_sub_network, 
    aes(x = x, y = y, 
      xend = xend, yend = yend)) +
 geom_edges(arrow = arrow(type = "closed", length = unit(8, "pt")), 
      aes(color = Y2000)) +
 geom_nodelabel(aes(label = name)) +
 labs(title = "Migration among selected countries",
    subtitle = "Among females in 2000",
    color = "Number who migrated") +
 theme_blank()
```

> part c- Run the code below to see the same plot with a different color scheme. Is this more or less effective (or about the same)? 

Solution:

```{r, fig.align = "center", fig.height = 3.5}
ggplot(data = migration_sub_network,
    aes(x = x, y = y, 
      xend = xend, yend = yend)) +
 geom_edges(arrow = arrow(type = "closed", length = unit(8, "pt")),
       curvature = 0.1,
       aes(color = Y2000)) +
 scale_color_continuous(type = "viridis") +
 geom_nodes(size = 5) +
 geom_nodelabel_repel(aes(label = name)) +
 labs(title = "Migration among selected countries",
    subtitle = "Among females in 2000",
    color = "Number who migrated") +
 theme_blank()
```

<!-- That's it for plots. Time to commit before moving on! -->

\newpage

# 3 - Network centrality statistics

Let's consider some centrality statistics for the migration network of your chosen countries. We'll use `degree()` and `strength()` from the **igraph** package for this.

> part a - Based on *degree centrality*, which country(countries) were most central to the migration network of your chosen countries in 2000? Does the answer differ depending on whether we consider all edges (total degree), or only outgoing edges (out-degree; how many destinations were there from that origin country?) or only incoming edges (in-degree; how many origins were there to that destination country?)?

Solution:

```{r}
igraph::degree(migration_sub_igraph) 

igraph::degree(migration_sub_igraph, mode = "out")

igraph::degree(migration_sub_igraph, mode = "in") 
```


> part b - The `degree()` function only counts the number of edges of each node, but it does not account for the varying weights of those edges. We can use the `strength()` function to compute the weighted degrees instead. Do the same countries stand out as having high degree centrality after considering the weighted edges?

Solution:


```{r}
# Get edge weights 
migration_edge_weights <- edge_attr(migration_sub_igraph, name = "Y2000")

# Total movement
strength(migration_sub_igraph, weights = migration_edge_weights)

# Total movement out
strength(migration_sub_igraph, weights = migration_edge_weights, mode = "out") 

# Total movement in
strength(migration_sub_igraph, weights = migration_edge_weights, mode = "in")
```

<!--
Great job! This showed you some basics of network analysis. A few more concepts follow
in the next example. Remember to commit and push.
-->

\newpage

# 4 - Network of Thrones

Consider the data described in the article, [*Network of Thrones*](https://www-jstor-org.ezproxy.amherst.edu/stable/10.4169/mathhorizons.23.4.18) (Beveridge and Shan, 2017). 

George R.R. Martin's fantasy novel, *A Storm of Swords*, was first published in 2000. About 13 years later, the first half of the novel was adapted for television in the third season of HBO's *Game of Thrones* (GoT). Our dataset is based on character interactions in the novel. Two characters are connected if their names appear within 15 words of one another in the novel. The dataset provides the edge lists and weights from the novel. The edge weight counts the number of these occurrences. The edge list is not directed (even though the variables names suggest such).

<!--
Adjust path based on where the data lives in relation to your .Rmd
-->

```{r}
got <- read_csv("data/storm-of-swords.csv")
```

> part a - Think about the text as data: Suppose, instead of the formatted data above, we had the entire text of the novel. List some of the steps (in English or pseudocode) required to wrangle the data into the form above.

Solution: 



> part b - How many GoT characters (nodes) and character interactions (edges) are in this network? 

Solution:

```{r}
# Create igraph object called got_igraph


# Identify number of nodes and edges

```

> part c - What proportion of possible edges are realized? 

This proportion is referred to as the "density" of a graph, which is a measure of how close the number of observed edges are to the maximal possible number of edges. Density ranges from 0 (least dense or sparser) to 1 (most dense) and can be obtained with the `edge_density()` function from **igraph**. Use this function to get the density, and verify it's correct by calculating the density yourself. 

Note: The number of *possible* edges in an undirected graph is ${V \choose 2} = \frac{V(V-1)}{2}$.

Solution:

```{r}

```

> part d - The function `is_connected()` returns "TRUE" if a graph is connected and "FALSE" otherwise. Is this graph connected? And if so, what does that mean? How would you be able to tell that the graph was connected by looking at Figure 2 in the [*Network of Thrones*](https://www-jstor-org.ezproxy.amherst.edu/stable/10.4169/mathhorizons.23.4.18) paper?

Solution:

```{r}

```

> part e - Use the code below to compute the diameter of the network. Interpret the value.

Solution:

```{r}
diameter(got_igraph, directed = FALSE)
```

<!--
Remember to commit!
-->

\newpage

# 5 - Network of Thrones: Centrality statistics

Next, let's consider the centrality statistics for characters in the network. The node degree counts the number of characters that a given character (node) is associated with. The weighted degree (given by `strength()`) is the sum of the edge weights for edges connecting one character (node) to other characters. In other words, the strength counts the total number of interactions a character has with others in the network. Below, we compute the degree and strength of each node, and combine these vectors into a dataframe. 

```{r}
got_stats <- data.frame(name = vertex_attr(got_igraph, "name"),
            degree = degree(got_igraph),
            strength = strength(got_igraph,
                      weights = edge_attr(got_igraph, "Weight")))
```

> part a - Who are the five characters with highest degree? Highest weighted degree? Verify that these values (look like they) match those in Figure 3 of the [*Network of Thrones*](https://www-jstor-org.ezproxy.amherst.edu/stable/10.4169/mathhorizons.23.4.18) paper. 

Solution:

```{r}

```

> part b - Explain how Robb can have higher degree than Bran but lower weighted degree.

You can answer this without knowing any of the GoT story. 

Solution:

```{r}
# may not need this chunk
```

> part c - Now consider the (unweighted) betweenness measure of centrality. In the code below, we use the `betweenness()` function to calculate the unweighted betweenness of the nodes, and add this statistics to the `got_stats` data frame using `add_column()`. Verify that the top ranked characters match those shown in Figure 3 of the *Network of Thrones* paper.

Solution:

```{r, }
got_stats <- got_stats %>% 
 add_column(betweenness = betweenness(got_igraph, weights = NA))
```


Lastly, let's consider eigenvector centrality and Google PageRank. The *Network of Thrones* paper gives a simple description of the page rank centrality measure. The basic idea is that a node will have a higher page rank value (and higher "centrality") if it is connected to important nodes. The page rank of node $i$ is a function of the weighted sum of the page ranks of its neighbors (who $i$ is connected to) with weights given by the edge weight between node $i$ and its neighbor, divided by the total weighted degree of the neighbor. 

Example: Consider the page ranks of Catelyn and Hodor. Both are connected to Bran, who has a weighted degree of 344. Bran has a total of 4 interactions with Catelyn so his page rank value is weighted by the fraction 4/344, or `r round(4/344, 2)`, when computing Catelyn's page rank. But Hodor's page rank calculation is influenced much more by Bran's value, since he has 96 interactions with Bran, which makes up a 96/344, or `r round(96/344,2)`, fraction of all of Bran's interactions. In this way, Hodor's page rank will be closer to Bran's value because he has more interactions with him than Catelyn. 

> part d - Use the provided code to add two variables to the `got_stats` dataframe: one with the unweighted eigenvector centrality, and a second with the unweighted page rank. Which characters score in the top 5 according to the page rank measure?

Solution:

```{r, eval = FALSE}
got_stats <- got_stats %>% 
 add_column(eigen = eigen_centrality(got_igraph, directed = FALSE, 
                                     weights = NA) %>% 
              purrr::pluck("vector"),
       pagerank = page_rank(got_igraph, directed = FALSE, 
                             weights = NA) %>% 
         purrr::pluck("vector"))

```

> part e - How can a character like Daenerys have such a high page rank, and a high rank for betweenness, but a low degree? (You can use Figure 2 in the *Network of Thrones* paper to visualize the structure.)


```{r}
# you may or may not need the code chunk
```

> part f - Finally, plot the network with node or label size determined by the page rank value. 

When plotting the graph, will it look better with igraph or ggnetwork being used? Use what will look better. 

Solution:

```{r}
# Add page rank as a vertex attribute


# Graph network

```

\newpage

# 6 - Community detection

Community detection in networks is a process of finding clusters of nodes (communities) that are highly connected within a cluster and have few connections across clusters. In other words, this is clustering, but as mentioned in your prep, the methods are very different. 

Figure 2 in the *Network of Thrones* paper uses color to denote the 7 communities found in their analysis. There are a variety of algorithms to do this, but most depend on calculating the modularity of the cluster assignment, which is a measure of how well a network can be divided into clusters. Modularity compares the edge weight between two nodes in the same cluster to the expected weight between the two nodes in a graph with a random assignment of edges. The higher the modularity value, the better the division into clusters (with a max value of 1). 

In *Network of Thrones*, the authors use the Louvain algorithm, which is a hierarchical method similar to hierarchical clustering for unsupervised learning. Nodes start out as individual clusters, then are merged together to create communities to increase modularity the most at each step (in a local, greedy way). The algorithm stops when the modularity value can't be increased by an additional step.

> part a - Run the code below to implement Louvain clustering and compute the modularity. What value did you obtain?

Solution:

```{r}
# Identify clusters using Louvain algorithm
got_cl <- cluster_louvain(got_igraph)
got_cl

# Compute modularity from Louvain clustering 
modularity(got_cl)
```

> part b - After clustering, we can determine how many nodes are in each detected cluster (i.e., how many characters are in each detected community). How many communities are there, and how many characters are there in each community?

Solution:

```{r}
communities(got_cl)
```

As we saw in the prep, you can plot the network with the following code, but this graph is harder to customize.

```{r}
plot(got_cl, got_igraph)
```

> part c - Create a better plot of the network with `ggplot()`, and color by group membership.

Solution:

```{r fig.height = 6.5}
# Get community membership
got_membership <- membership(got_cl)

# Add community membership as vertex attribute


# Create a plot

```


<!-- Commit and push your final file including the compiled renamed pdf to your repo! -->
